{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About fast_matched_filter (FMF) An efficient seismic matched-filter search for both CPU and GPU architectures. If you use FMF in research to be published, please reference the following article: Beauc\u00e9, Eric, W. B. Frank, and Alexey Romanenko (2017). Fast matched-filter (FMF): an efficient seismic matched-filter search for both CPU and GPU architectures. Seismological Research Letters , doi: 10.1785/0220170181 FMF is available at https://github.com/beridel/fast_matched_filter and can be downloaded with: $ git clone https://github.com/beridel/fast_matched_filter.git Required software/hardware: - A C compiler that supports OpenMP (default Mac OS compiler clang does not support OpenMP; gcc can be easily downloaded via homebrew), - CPU version: either Python (v2.7 or 3.x) or Matlab, - GPU version: Python (v2.7 or 3.x) and a discrete Nvidia graphics card that supports CUDA C with CUDA toolkit installed. FMF is known to run well with gcc 4.8.4 or 4.8.5, and cuda 7.5. Installation After downloading FMF, go to the main folder. A simple make + whichever implementation does the trick. Possible make commands are: $ make python_cpu $ make python_gpu $ make matlab NB: Matlab compiles via mex, which needs to be setup before running. Any compiler can be chosen during the setup of mex, because it will be bypassed by the CC environment variable in the Makefile. Therefore CC must be set to an OpenMP-compatible compiler. Also, make sure the mex_extension variable in the Makefile corresponds to your OS (the different variables for each OS are listed in the Makefile). Installation as a Python module is possible via setup tools or even pip (which supports clean uninstalling): $ python setup.py build $ python setup.py install OR (preferred option for a Python user, since it will install FMF to your standard package directory) $ python setup.py build $ pip install . Running Matlab : Matlab only supports the CPU version, which is called with the fast_matched_filter function (provided in the fast_matched_filter.m file). Python : Both CPU and GPU versions are called with the matched_filter function. If FMF was installed as a Python module, it can be imported via: import fast_matched_filter as fmf","title":"Introduction"},{"location":"#about-fast_matched_filter-fmf","text":"An efficient seismic matched-filter search for both CPU and GPU architectures. If you use FMF in research to be published, please reference the following article: Beauc\u00e9, Eric, W. B. Frank, and Alexey Romanenko (2017). Fast matched-filter (FMF): an efficient seismic matched-filter search for both CPU and GPU architectures. Seismological Research Letters , doi: 10.1785/0220170181 FMF is available at https://github.com/beridel/fast_matched_filter and can be downloaded with: $ git clone https://github.com/beridel/fast_matched_filter.git Required software/hardware: - A C compiler that supports OpenMP (default Mac OS compiler clang does not support OpenMP; gcc can be easily downloaded via homebrew), - CPU version: either Python (v2.7 or 3.x) or Matlab, - GPU version: Python (v2.7 or 3.x) and a discrete Nvidia graphics card that supports CUDA C with CUDA toolkit installed. FMF is known to run well with gcc 4.8.4 or 4.8.5, and cuda 7.5.","title":"About fast_matched_filter (FMF)"},{"location":"#installation","text":"After downloading FMF, go to the main folder. A simple make + whichever implementation does the trick. Possible make commands are: $ make python_cpu $ make python_gpu $ make matlab NB: Matlab compiles via mex, which needs to be setup before running. Any compiler can be chosen during the setup of mex, because it will be bypassed by the CC environment variable in the Makefile. Therefore CC must be set to an OpenMP-compatible compiler. Also, make sure the mex_extension variable in the Makefile corresponds to your OS (the different variables for each OS are listed in the Makefile). Installation as a Python module is possible via setup tools or even pip (which supports clean uninstalling): $ python setup.py build $ python setup.py install OR (preferred option for a Python user, since it will install FMF to your standard package directory) $ python setup.py build $ pip install .","title":"Installation"},{"location":"#running","text":"Matlab : Matlab only supports the CPU version, which is called with the fast_matched_filter function (provided in the fast_matched_filter.m file). Python : Both CPU and GPU versions are called with the matched_filter function. If FMF was installed as a Python module, it can be imported via: import fast_matched_filter as fmf","title":"Running"},{"location":"tutorial/","text":"This tutorial shows how to detect new seismic events with template matching starting from a known earthquake (using FMF, of course!). The tutorial is organized into a series of four python jupyter notebooks. Prerequisite We provide the material required by this tutorial at: https://www.dropbox.com/sh/3vvwn072o0kde05/AAATww2-BkKRRGf9SyjBjNC8a?dl=0 To avoid issues caused by package discrepancies, we provide a conda environment ready for cloning. If you do not have the anaconda distribution, please have a look at https://www.anaconda.com/distribution/ . To clone our environment, go to the main folder tuto_material and run: conda create --name FMF_tuto --file FMF_tuto_Python_packages.txt Activate your new conda environment with: source activate FMF_tuto You now need to install FMF. Move to the folder fast_matched_filter and run: python setup.py build pip install . We also refer you to the installation tab of this documentation.","title":"Tutorial"},{"location":"tutorial/#prerequisite","text":"We provide the material required by this tutorial at: https://www.dropbox.com/sh/3vvwn072o0kde05/AAATww2-BkKRRGf9SyjBjNC8a?dl=0 To avoid issues caused by package discrepancies, we provide a conda environment ready for cloning. If you do not have the anaconda distribution, please have a look at https://www.anaconda.com/distribution/ . To clone our environment, go to the main folder tuto_material and run: conda create --name FMF_tuto --file FMF_tuto_Python_packages.txt Activate your new conda environment with: source activate FMF_tuto You now need to install FMF. Move to the folder fast_matched_filter and run: python setup.py build pip install . We also refer you to the installation tab of this documentation.","title":"Prerequisite"},{"location":"usage/","text":"Description of the Arguments The wrapper function matched_filter takes 6 arguments (5 arguments only for the Matlab version): - templates: array with the template waveforms to search for in the continuous data, - moveouts: array with the relative arrival times (in samples) associated with each template, - weights: array with the weights used in the weighted sum of the correlation coefficients, - data: array with the continuous data, - step: temporal step (in samples) between two consecutive calculations of the correlation coefficient, - arch (Python only): architecture used to run FMF ('cpu' or 'gpu', default is 'cpu'). Because Matlab and Python use different conventions for the mapping between the indexing and the location in memory, the input arrays have different dimensions depending on whether Matlab or Python is used. Matlab: In Matlab, the most contiguous dimension is the first one. Therefore, the arrays should have dimensions: - continuous data (n_samples_data, n_components, n_stations) - template waveforms (n_samples_template, n_components, n_stations, n_detections) - moveouts (n_components, n_stations) - weights (n_components, n_stations) Python: In Python, the most contiguous dimension is the last one. Therefore, the arrays should have dimensions: - continuous data (n_stations, n_components, n_samples_data) - template waveforms (n_detections, n_stations, n_components, n_samples_template) - moveouts (n_stations, n_components) - weights (n_stations, n_components) Output of FMF FMF returns the time series of the average correlation coefficients (CC) calculated for each template given in input. Therefore, the output has dimensions: - Python: (n_templates, n_correlations), - Matlab: (n_correlations, n_templates). The number of correlations (n_correlations) is determined by the length of the continuous data and the temporal step you used. Given the 6 input arguments described here, the correlation coefficients are obtained by calling the wrapper function in the following way: Matlab: cc = fast_matched_filter(templates, moveouts, weights, data, step) cc(:, i) is the correlation coefficient time series for the i-th template. Python: cc = matched_filter(templates, moveouts, weights, data, step, arch='cpu' or 'gpu') cc[i,:] is the correlation coefficient time series for the (i+1)-th template. To perform earthquake detection from the CC time series, we typically look for the samples that exceed a threshold defined by 8xRMS or 10xMAD ( cf. figure below). Figure from: Beauc\u00e9, Eric, W. B. Frank, and Alexey Romanenko (2017). Fast matched-filter (FMF): an efficient seismic matched-filter search for both CPU and GPU architectures. Seismological Research Letters , doi: 10.1785/0220170181","title":"Usage"},{"location":"usage/#description-of-the-arguments","text":"The wrapper function matched_filter takes 6 arguments (5 arguments only for the Matlab version): - templates: array with the template waveforms to search for in the continuous data, - moveouts: array with the relative arrival times (in samples) associated with each template, - weights: array with the weights used in the weighted sum of the correlation coefficients, - data: array with the continuous data, - step: temporal step (in samples) between two consecutive calculations of the correlation coefficient, - arch (Python only): architecture used to run FMF ('cpu' or 'gpu', default is 'cpu'). Because Matlab and Python use different conventions for the mapping between the indexing and the location in memory, the input arrays have different dimensions depending on whether Matlab or Python is used. Matlab: In Matlab, the most contiguous dimension is the first one. Therefore, the arrays should have dimensions: - continuous data (n_samples_data, n_components, n_stations) - template waveforms (n_samples_template, n_components, n_stations, n_detections) - moveouts (n_components, n_stations) - weights (n_components, n_stations) Python: In Python, the most contiguous dimension is the last one. Therefore, the arrays should have dimensions: - continuous data (n_stations, n_components, n_samples_data) - template waveforms (n_detections, n_stations, n_components, n_samples_template) - moveouts (n_stations, n_components) - weights (n_stations, n_components)","title":"Description of the Arguments"},{"location":"usage/#output-of-fmf","text":"FMF returns the time series of the average correlation coefficients (CC) calculated for each template given in input. Therefore, the output has dimensions: - Python: (n_templates, n_correlations), - Matlab: (n_correlations, n_templates). The number of correlations (n_correlations) is determined by the length of the continuous data and the temporal step you used. Given the 6 input arguments described here, the correlation coefficients are obtained by calling the wrapper function in the following way: Matlab: cc = fast_matched_filter(templates, moveouts, weights, data, step) cc(:, i) is the correlation coefficient time series for the i-th template. Python: cc = matched_filter(templates, moveouts, weights, data, step, arch='cpu' or 'gpu') cc[i,:] is the correlation coefficient time series for the (i+1)-th template. To perform earthquake detection from the CC time series, we typically look for the samples that exceed a threshold defined by 8xRMS or 10xMAD ( cf. figure below). Figure from: Beauc\u00e9, Eric, W. B. Frank, and Alexey Romanenko (2017). Fast matched-filter (FMF): an efficient seismic matched-filter search for both CPU and GPU architectures. Seismological Research Letters , doi: 10.1785/0220170181","title":"Output of FMF"}]}